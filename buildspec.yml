version: 0.2

env:
  shell: bash
  parameter-store:
    BASE_AMI: /backend/base-ami-id
    SUBNET_ID: /backend/subnet-id
    SG_ID: /backend/security-group-id
    IAM_PROFILE: /backend/iam-profile
    LAUNCH_TEMPLATE: /backend/launch-template
    ASG_NAME: /backend/asg-name
    GIT_BRANCH: /backend/git-branch
    ENVIRONMENT: /backend/environment

phases:
  install:
    runtime-versions:
      python: 3.11
    commands:
      - echo "Installing dependencies"
      - pip install --upgrade awscli jq
      - apt-get update && apt-get install -y unzip || true
      - echo "AWS CLI version: $(aws --version)"

  pre_build:
    commands:
      - echo "=== DEPLOYMENT STARTED ==="
      - echo "Environment: ${ENVIRONMENT}"
      - echo "Git Commit: ${CODEBUILD_RESOLVED_SOURCE_VERSION}"
      - BUILD_TIMESTAMP=$(date +%Y%m%d%H%M%S)
      - AMI_NAME="backend-${ENVIRONMENT}-${BUILD_TIMESTAMP}"
      - INSTANCE_TYPE="t3.micro"
      - export DEPLOYMENT_ID="deploy-${BUILD_TIMESTAMP}"
      - |
        for param in BASE_AMI SUBNET_ID SG_ID IAM_PROFILE LAUNCH_TEMPLATE ASG_NAME; do
          if [ -z "${!param}" ]; then
            echo "ERROR: Parameter $param is empty!"
            exit 1
          fi
        done

  build:
    commands:
      - |
        echo "=== STEP 1: Launching build instance ==="
        set -e
        INSTANCE_TAGS='ResourceType=instance,Tags=[{Key=Name,Value=backend-build-'"${BUILD_TIMESTAMP}"'},{Key=Environment,Value='"${ENVIRONMENT}"'},{Key=DeploymentID,Value='"${DEPLOYMENT_ID}"'},{Key=Commit,Value='"${CODEBUILD_RESOLVED_SOURCE_VERSION}"'}]'
        INSTANCE_ID=$(aws ec2 run-instances --image-id "$BASE_AMI" --instance-type "$INSTANCE_TYPE" --subnet-id "$SUBNET_ID" --security-group-ids "$SG_ID" --iam-instance-profile Name="$IAM_PROFILE" --tag-specifications "$INSTANCE_TAGS" --block-device-mappings 'DeviceName=/dev/xvda,Ebs={VolumeSize=20,VolumeType=gp3,DeleteOnTermination=true}' --query 'Instances[0].InstanceId' --output text)
        echo "Instance created: $INSTANCE_ID"
        echo $INSTANCE_ID > instance_id.txt
      - |
        echo "Waiting for instance to be ready (SSM agent running)..."
        for i in {1..30}; do
          if aws ssm describe-instance-information --filters "Key=InstanceIds,Values=$INSTANCE_ID" --query "InstanceInformationList[0].PingStatus" --output text | grep -q "Online"; then
            echo "Instance is online and ready for SSM commands"
            break
          fi
          echo "Waiting for SSM agent... ($i/30)"
          sleep 10
          if [ $i -eq 30 ]; then
            echo "ERROR: SSM agent did not come online in time"
            exit 1
          fi
        done
      - |
        echo "=== STEP 2: Deploying code via SSM ==="
        cat > /tmp/deploy.sh << 'EOF'
        #!/bin/bash
        set -e
        echo "Starting deployment..."
        echo "Git commit: $COMMIT_HASH"
        cd /opt/backend
        git fetch origin
        git checkout -f $COMMIT_HASH
        npm ci --only=production
        systemctl daemon-reload
        systemctl restart backend
        sleep 5
        if systemctl is-active --quiet backend; then
          echo "✅ Service is running"
          echo "Version: $(git rev-parse --short HEAD)" > /opt/backend/version.txt
        else
          echo "❌ Service failed to start"
          journalctl -u backend --no-pager -n 30
          exit 1
        fi
        EOF
        DEPLOY_COMMAND_ID=$(aws ssm send-command --instance-ids "$INSTANCE_ID" --document-name "AWS-RunShellScript" --comment "Deploy backend ${DEPLOYMENT_ID}" --parameters '{"commands": ["cat > /tmp/deploy.sh", "chmod +x /tmp/deploy.sh", "/tmp/deploy.sh"], "env": [{"name": "COMMIT_HASH", "value": "'"${CODEBUILD_RESOLVED_SOURCE_VERSION}"'"}]}' --cloud-watch-output-config 'CloudWatchLogGroupName=/backend/deployments,CloudWatchOutputEnabled=true' --query "Command.CommandId" --output text)
        echo "Deployment command ID: $DEPLOY_COMMAND_ID"
      - |
        echo "Waiting for deployment to complete..."
        for i in {1..30}; do
          STATUS=$(aws ssm get-command-invocation --command-id "$DEPLOY_COMMAND_ID" --instance-id "$INSTANCE_ID" --query "Status" --output text 2>/dev/null || echo "Pending")
          case $STATUS in
            "Success")
              echo "✅ Deployment successful!"
              aws ssm get-command-invocation --command-id "$DEPLOY_COMMAND_ID" --instance-id "$INSTANCE_ID" --query "StandardOutputContent" --output text
              break
              ;;
            "Failed"|"Cancelled"|"TimedOut")
              echo "❌ Deployment failed with status: $STATUS"
              aws ssm get-command-invocation --command-id "$DEPLOY_COMMAND_ID" --instance-id "$INSTANCE_ID" --query "StandardErrorContent" --output text
              exit 1
              ;;
            *)
              echo "⏳ Deployment status: $STATUS ($i/30)"
              sleep 10
              ;;
          esac
          if [ $i -eq 30 ]; then
            echo "⏰ Deployment timeout"
            exit 1
          fi
        done
      - |
        echo "=== STEP 3: Creating AMI ==="
        AMI_TAGS='ResourceType=image,Tags=[{Key=Name,Value='"${AMI_NAME}"'},{Key=Environment,Value='"${ENVIRONMENT}"'},{Key=DeploymentID,Value='"${DEPLOYMENT_ID}"'},{Key=Commit,Value='"${CODEBUILD_RESOLVED_SOURCE_VERSION}"'}]'
        AMI_ID=$(aws ec2 create-image --instance-id "$INSTANCE_ID" --name "$AMI_NAME" --description "Backend deployment ${DEPLOYMENT_ID}, Commit: ${CODEBUILD_RESOLVED_SOURCE_VERSION}" --no-reboot --tag-specifications "$AMI_TAGS" --query "ImageId" --output text)
        echo "AMI creation started: $AMI_ID"
        echo $AMI_ID > ami_id.txt
      - |
        echo "Waiting for AMI to be available..."
        aws ec2 wait image-available --image-ids "$AMI_ID" --filters "Name=state,Values=available" --region "$(echo $AWS_DEFAULT_REGION)"
        echo "✅ AMI is ready: $AMI_ID"

  post_build:
    commands:
      - echo "=== STEP 4: Updating infrastructure ==="
      - AMI_ID=$(cat ami_id.txt)
      - |
        echo "Creating new Launch Template version..."
        LT_VERSION=$(aws ec2 create-launch-template-version --launch-template-name "$LAUNCH_TEMPLATE" --source-version '$Latest' --launch-template-data '{"ImageId":"'"$AMI_ID"'","InstanceType":"t3.micro","TagSpecifications": [{"ResourceType":"instance","Tags":[{"Key":"DeploymentID","Value":"'"${DEPLOYMENT_ID}"'"}]}]}' --query "LaunchTemplateVersion.VersionNumber" --output text)
        echo "Launch Template version $LT_VERSION created"
        echo $LT_VERSION > lt_version.txt
      - |
        echo "Updating Auto Scaling Group..."
        CURRENT_CAPACITY=$(aws autoscaling describe-auto-scaling-groups --auto-scaling-group-names "$ASG_NAME" --query "AutoScalingGroups[0].DesiredCapacity" --output text)
        aws autoscaling update-auto-scaling-group --auto-scaling-group-name "$ASG_NAME" --launch-template "LaunchTemplateName=$LAUNCH_TEMPLATE,Version=$LT_VERSION" --desired-capacity $CURRENT_CAPACITY
      - |
        echo "Starting instance refresh..."
        REFRESH_ID=$(aws autoscaling start-instance-refresh --auto-scaling-group-name "$ASG_NAME" --strategy Rolling --preferences '{"MinHealthyPercentage": 90, "InstanceWarmup": 300, "SkipMatching": true, "ScaleInProtectedInstances": "Ignore", "StandbyInstances": "Ignore"}' --query "InstanceRefreshId" --output text)
        echo "Instance Refresh ID: $REFRESH_ID"
        echo $REFRESH_ID > refresh_id.txt
      - |
        echo "Waiting for instance refresh to complete..."
        for i in {1..60}; do
          STATUS=$(aws autoscaling describe-instance-refreshes --auto-scaling-group-name "$ASG_NAME" --instance-refresh-ids "$REFRESH_ID" --query "InstanceRefreshes[0].Status" --output text)
          case $STATUS in
            "Successful")
              echo "✅ Instance refresh completed successfully"
              break
              ;;
            "Failed"|"Cancelled")
              echo "❌ Instance refresh failed: $STATUS"
              break
              ;;
            *)
              echo "⏳ Instance refresh status: $STATUS ($i/60)"
              sleep 30
              ;;
          esac
        done
      - |
        echo "Cleaning up old AMIs..."
        aws ec2 describe-images --owners self --filters "Name=tag:Environment,Values=${ENVIRONMENT}" --query "Images[?Tags[?Key=='Name' && starts_with(Value, 'backend-${ENVIRONMENT}-')]].ImageId" --output text | tr '\t' '\n' | sort -r | tail -n +6 | while read OLD_AMI; do
          echo "Deregistering old AMI: $OLD_AMI"
          aws ec2 deregister-image --image-id "$OLD_AMI" || true
        done
      - |
        echo "Terminating build instance..."
        aws ec2 terminate-instances --instance-ids "$INSTANCE_ID" --query "TerminatingInstances[0].CurrentState.Name" --output text
        echo "=== DEPLOYMENT COMPLETE ==="
        echo "AMI: $AMI_ID"
        echo "Launch Template Version: $LT_VERSION"
        echo "Instance Refresh: $REFRESH_ID"

  on-failure:
    commands:
      - echo "=== DEPLOYMENT FAILED ==="
      - |
        if [ -f instance_id.txt ]; then
          INSTANCE_ID=$(cat instance_id.txt)
          echo "Terminating failed build instance: $INSTANCE_ID"
          aws ec2 terminate-instances --instance-ids "$INSTANCE_ID" || true
        fi
      - echo "Check CloudWatch Logs: /backend/deployments"
      - echo "Check SSM Command History for details"

artifacts:
  files:
    - instance_id.txt
    - ami_id.txt
    - lt_version.txt
    - refresh_id.txt
  discard-paths: yes

reports:
  deploy-report:
    files:
      - '**/*'
    base-directory: '.'
    file-format: 'JUNITXML'
